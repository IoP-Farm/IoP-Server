# IoP-Farm: Умная автоматизированная ферма на ESP32

**Версия:** 1.0  
**Дата:** 10.05.2025

---

## Оглавление

- [О проекте](#о-проекте)
- [Краткие возможности](#краткие-возможности)
- [Быстрый старт: PlatformIO environments и первичная загрузка](#быстрый-старт-platformio-environments-и-первичная-загрузка)
- [Архитектура и основные компоненты](#архитектура-и-основные-компоненты)
- [Калибровка и особенности работы датчиков](#калибровка-и-особенности-работы-датчиков)
- [Изменяемые параметры в constants.h](#изменяемые-параметры-в-constantsh)
- [Управление с телефона и мониторинг через Android-приложение](#управление-с-телефона-и-мониторинг-через-android-приложение)
- [OTA-обновления](#ota-обновления)
- [Работа с логами и диагностика](#работа-с-логами-и-диагностика)
- [Масштабирование и расширение](#масштабирование-и-расширение)
- [Безопасность](#безопасность)
- [FAQ и советы](#faq-и-советы)
- [Важные замечания](#важные-замечания)
- [Контакты и поддержка](#контакты-и-поддержка)
- [Сервер-посредник и хранение данных](#сервер-посредник-и-хранение-данных)
- [Минимальные примеры кода](#минимальные-примеры-кода)

---

## О проекте

**IoP-Farm** — это модульная система для автоматизации домашних и лабораторных агроустановок на базе ESP32. Система поддерживает работу с различными датчиками и исполнительными устройствами, интеграцию с WiFi/MQTT, удаленное управление и обновление прошивки по воздуху (OTA). Проект ориентирован на максимальную надежность, расширяемость и простоту первичной настройки.

---

## Краткие возможности

- Автоматический полив по расписанию и объему воды
- Контроль температуры и автоматическое управление нагревом
- Управление освещением по расписанию
- Поддержка WiFi 2.4 ГГц (WPA2/WPA3, STA и точка доступа) для управления с телефона.
- MQTT-интеграция для сбора данных и управления
- Гибкая система конфигурирования (web-интерфейс, WiFiManager, настройка с приложения на Android)
- OTA-обновления (PlatformIO, web-интерфейс, WiFiManager)
- Логирование (Serial, MQTT)
- Модульная архитектура: легко добавлять новые датчики, актуаторы, стратегии
- Хранение всех настроек в энергонезависимой памяти (SPIFFS), автоматическая загрузка последних/дефолтных конфигов в зависимости флага компиляции
- Безопасность: аутентификация web-интерфейса при загрузки прошивки по OTA
- Масштабируемость: поддержка новых топиков MQTT, устройств, стратегий

---

## Быстрый старт: PlatformIO environments и первичная загрузка

### Как устроен platformio.ini

В проекте определено несколько сред (environments) для разных сценариев работы и отладки. Это позволяет гибко управлять процессом прошивки, конфигурирования и обновления устройства.

#### Основные environments:

- `[env:esp32doit-devkit-v1]` — **Штатный режим без лишних логов**. Используется для финальной эксплуатации, когда не требуется подробная отладка.
- `[env:debug]` — **Режим с подробным логированием** (рекомендуется для разработки и диагностики). Выводит максимум информации в Serial и MQTT.
- `[env:load_default_configs]` — **Первичная загрузка**. Используется только при первом запуске нового микроконтроллера или для сброса к заводским настройкам. Загружает дефолтные конфиги и включает расширенное логирование.
- `[env:debugOTA_320WiFi5]`, `[env:debugOTAVenom]` — **OTA-обновления через PlatformIO**. Примеры для разных сетей. Для своей сети скопируйте любой из этих блоков, поменяйте `upload_port` на IP вашей ESP32 в локальной сети, к которой она подключается и (если вы выставили нестандартный пароль) `upload_flags` с новым паролем.

Выбор environment происходит на панели управления platformio.ini в нижней части экрана.

#### Пример добавления своей среды для OTA:

```ini
[env:debugOTA_MyNetwork]
platform = espressif32
board = esp32doit-devkit-v1
framework = arduino
upload_protocol = espota
upload_port = <IP_ESP32>
upload_flags = 
    --auth=<ваш_пароль>
; остальные параметры аналогичны debug
```

Для загрузки прошивки по ArduinoOTA через созданную среду необходимо выставить в настройках platformio.ini (на панели управления в нижней части экрана) в качестве порта локальный IP ESP32 в вашей сети, компьютер при этом тоже должен быть подключен к тому же WiFi. Если все было выставлено, убедитесь, что ESP32 подключен к данному WiFi и загрузите прошивку, нажав Upload на панели управления platformio.ini.

### Порядок действий при первичной загрузке

1. **Клонируйте репозиторий и установите PlatformIO.**
2. **Загрузка файлов конфигурации в SPIFFS**
   - После любой смены конфигов или при первом запуске обязательно загрузите все файлы из папки `data/` на ESP32:
     ```
     pio run --target uploadfs
     ```
   - Это создаст в SPIFFS все необходимые конфиги (`data.json`, `config.json`, `mqtt.json`, `passwords.json` и их дефолтные версии).
3. **Загрузка дефолтных конфигов**
   - Перед началом работы необходимо загрузить файлы из папки `data/` в энергонезависимую память SPIFFS. См. пункт 2.
   - Затем обязательно используйте `[env:load_default_configs]` для самой первой прошивки нового микроконтроллера.
   - Это обеспечит корректную инициализацию всех файлов настроек во Flash.
   - После этого рекомендуется сразу перейти на `[env:debug]` для дальнейшей работы. 
4. **Подключитесь к точке доступа ESP32 и настройте WiFi/MQTT через портал.**
5. **Проверьте работу системы через web-интерфейс и MQTT.**


**Перепрошивка и эксплуатация**
   - Для обычной работы используйте `[env:debug]` (рекомендуется) или `[env:esp32doit-devkit-v1]` (минимум логов).
   - Для OTA-обновлений используйте соответствующую OTA-среду или создайте свою.
   - Для других способов перепрошивки см. раздел `OTA Обновления`.

---

## Архитектура и основные компоненты

### Менеджеры и их логика

- **WiFiManager** — автоматическое подключение к WiFi, поднятие точки доступа при ошибках, настройка через captive portal.
- **MQTTManager** — подключение к серверу, подписка на топики, обработка команд, автоматическое повторное подключение при разрыве соединения.
- **ConfigManager** — хранение всех настроек в SPIFFS, поддержка дефолтных и пользовательских конфигов.
- **OTAManager** — поддержка OTA-обновлений через PlatformIO, web-интерфейс и WiFiManager.
- **WebServerManager** — web-интерфейс для OTA и диагностики, с аутентификацией.

### Датчики и исполнительные устройства

- **Датчики**: DHT22, DS18B20, HC-SR04, FC-28, KY-018, YFS401 (только один на систему!)
- **Актуаторы**: насос R385, тепловая лампа, фитолента
- **Схемы подключения**: см. заголовочные файлы в `include/sensors/*.h` и `include/actuators/*.h`. Также см. `scheme.pdf`, в котором подробно нарисована понятная и подробная схема подключения.

---

## Калибровка и особенности работы датчиков

- **FC-28**: калибруется по сухой и влажной почве (см. `FC28.h`).
- **HC-SR04**: требует калибровки коэффициентов (использована МНК-калибровка, см. `HCSR04.h`).
- **YFS401**: калибруется по количеству импульсов на литр (см. `YFS401.h`). В системе поддерживается только один расходомер!

---

## Изменяемые параметры в constants.h

Практически все базовые параметры системы вынесены в файл `include/config/constants.h`. Это позволяет гибко адаптировать прошивку под свои задачи без глубокого погружения в код. После изменения большинства параметров требуется пересборка и перепрошивка устройства.

### Что можно менять:

- **Идентификатор устройства и MQTT**
  - `mqtt::DEFAULT_DEVICE_ID` — уникальный идентификатор вашей фермы для MQTT-топиков.
  - `mqtt::DEFAULT_HOST`, `mqtt::DEFAULT_PORT` — адрес и порт MQTT-брокера по умолчанию.
- **WiFi и точка доступа**
  - `wifi::DEFAULT_AP_NAME`, `wifi::DEFAULT_AP_PASSWORD` — имя и пароль точки доступа ESP32.
  - `wifi::DEFAULT_HOSTNAME` — имя устройства в сети.
  - Таймауты подключения, интервалы переподключения (`CONNECT_TIMEOUT`, `RECONNECT_RETRY_INTERVAL` и др.).
- **Пины подключения датчиков и актуаторов**
  - Все пины для датчиков (`sensors::pins::...`) и исполнительных устройств (`actuators::pins::...`).
  - Можно переназначить под свою разводку платы.
- **Калибровочные значения и параметры датчиков**
  - Например, `sensors::calibration::FC28_DRY_VALUE`, `YFS401_CALIBRATION_FACTOR`, `HCSR04_A`, `HCSR04_B` и др.
  - Позволяет точно откалибровать систему под вашу физическую установку.
- **Пороговые значения ошибок и "нет данных"**
  - `sensors::calibration::SENSOR_ERROR_VALUE`, `NO_DATA` — значения, которые система возвращает при ошибке или отсутствии данных.
- **Параметры стратегий управления**
  - В пространствах имен `strategies::irrigation`, `strategies::heating`, `strategies::lighting` можно изменить интервалы, гистерезисы, расписания и т.д.
- **Интервалы работы системы**
  - Например, `sensors::timing::DEFAULT_READ_INTERVAL` — период опроса датчиков.
  - `actuators::CHECK_INTERVAL` — частота проверки актуаторов.
- **Логгирование**
  - В пространстве имен `log::constants` можно изменить уровни логирования, цвета, буферы, минимальный уровень для отправки логов в MQTT и др.
- **Команды управления**
  - В enum `CommandCode` можно добавить или изменить коды команд для MQTT.
- **Временные параметры**
  - `time::DEFAULT_GMT_OFFSET`, `time::NTP_PERIOD` — часовой пояс и период синхронизации времени. По умолчанию выставлен GMT+3 (Москва).

### Как менять параметры

1. Откройте файл `include/config/constants.h` в редакторе.
2. Найдите нужный параметр (используйте поиск по имени).
3. Измените значение на свое (например, смените пин, пароль, deviceId, калибровку).
4. Сохраните файл, пересоберите и перепрошейте проект.

**Важно:**
- После изменения параметров в constants.h всегда пересобирайте проект и загружайте новую прошивку на ESP32.
- Некоторые параметры (например, deviceId, пароли, пины) критичны для работы системы — меняйте их осознанно.
- Для изменения логина/пароля web-интерфейса используйте файл `passwords.json`.

---

## Управление с телефона и мониторинг через Android-приложение

Система IoP-Farm поддерживает полноценное управление и мониторинг с мобильного устройства благодаря специально разработанному Android-приложению. Это позволяет:

- **Просматривать показания всех датчиков** (температура, влажность, уровень воды, освещенность и др.) в реальном времени прямо на экране телефона.
- **Управлять исполнительными устройствами** (насос, лампа нагрева, фитолента) дистанционно — запускать/останавливать вручную или по расписанию.
- **Менять параметры конфигурации** (например, расписание полива, целевые значения температуры, объем воды и т.д.) без необходимости перепрошивки устройства.
- **Получать уведомления о событиях и ошибках** — все логи и предупреждения отправляются в отдельный топик и могут быть просмотрены в приложении (еще не реализовано, данный функционал доступен лишь при подключении к серверу напрямую).

### Как работает обмен данными

Вся коммуникация между ESP32 и приложением строится на протоколе MQTT. Для каждого устройства (фермы) используется уникальный идентификатор (например, `farm001`).

- **Загрузка конфигурации**: приложение получает настройки из топика `farm001/config`.
- **Мониторинг данных**: все показания датчиков публикуются устройством в топик `farm001/data`.
- **Управление и команды**: приложение отправляет команды в топик `farm001/command`, которые тут же обрабатываются системой.
- **Логи и диагностика**: все события, ошибки и служебные сообщения отправляются в топик `farm001/logs`.

### Пример работы

1. **Настройте приложение**: укажите адрес MQTT-брокера, порт и идентификатор устройства (`deviceId`).
2. **Подключитесь к ферме**: приложение автоматически загрузит текущую конфигурацию и начнет получать данные с датчиков.
3. **Управляйте устройствами**: включайте/выключайте насос, лампу, свет, меняйте расписание и параметры прямо с телефона.
4. **Следите за состоянием**: все логи, ошибки и предупреждения отображаются в приложении (в дальнейшем) для быстрого реагирования.

### Требования

- ESP32 и телефон должны быть подключены к сети, ESP32 должен иметь доступ к MQTT брокеру.
- В конфигурации устройства должен быть корректно задан `deviceId` (например, `farm001`), хост и порт сервера.

**Преимущества:**
- Не требуется физический доступ к устройству для настройки и управления.
- Все изменения применяются мгновенно, без перепрошивки.
- Удобный мониторинг и диагностика в одном месте.

---

## Сервер-посредник и хранение данных

Для повышения надежности, безопасности и удобства работы в системе IoP-Farm реализован собственный сервер-посредник. Он выполняет следующие функции:

- **Маршрутизация всех сообщений** между ESP32 (фермой) и мобильным приложением. Все сообщения MQTT-топиков (`config`, `data`, `command`, `logs`) проходят через сервер, что позволяет централизованно управлять обменом данными.
- **Хранение данных**: сервер сохраняет все показания датчиков, команды, логи и конфигурации в собственной базе данных. Это обеспечивает:
  - Исторический мониторинг и анализ данных
  - Возможность восстановления состояния после сбоев
  - Централизованный доступ к информации с разных устройств
- **Безопасность и контроль доступа**: сервер может реализовывать аутентификацию, авторизацию и другие механизмы защиты (по мере развития системы, это еще не реализовано).

### Запуск серверной части

Для работы всей системы необходимо развернуть сервер и запустить соответствующие сервисы:

- [Здесь будет список необходимых сервисов и инструкции по запуску]

_Подробная документация по установке и настройке серверной части появится в следующих версиях._

P.S: на данный момент все сервисы запущены в фоновом режиме на нашем сервере. Если у вас есть собственный сервер и собственный MQTT брокер - запустите MQTT на определенном порту и настройте в дефолтных натсройках или в точке доступа WiFiManager новый хост и порт MQTT брокера для пересылки данных.

---

## OTA-обновления

- **PlatformIO OTA**: используйте соответствующую среду, будьте в одной сети с ESP32, пароль по умолчанию `12345678`.
- **Web-интерфейс**: доступен по адресу ESP32, требуется аутентификация (логин/пароль из `passwords.json`. Для его изменения необходимо будет заново загрузить дефолтные настройки, см. `Загрузка файлов конфигурации в SPIFFS`).
- **WiFiManager**: при потере или отсутствии связи ESP32 поднимает точку доступа, там же можно обновить прошивку. Пароль по умолчанию `12345678`, можно изменить в файле `constants.h`. Точка доступа ESP32 будет высвечена в списке доступных WiFi-сетей на вашем устройстве.

---

## Работа с логами и диагностика

- Логи выводятся в Serial и/или отправляются на MQTT. Тип логгирования можно изменить в самом начале `main.cpp`, создав нужный логгер при помощи фабрики
- Светодиод на плате сигнализирует о проблемах с WiFi/MQTT (горит — нет связи с WiFi или MQTT, либо происходит подключение к WiFi).
- Данные с датчиков: `-50` — нет данных, `-100` — ошибка чтения. Данные константы можно изменить в `constants.h`
- Расходомер не отправляет данные на сервер, используется только насосом.

---

## Масштабирование и расширение

- Добавляйте новые датчики/актуаторы через наследование от `ISensor`/`IActuator`.
- Новые стратегии — через наследование от `IActuatorStrategy` и регистрацию в менеджере.
- Для новых топиков MQTT — пропишите их в `constants.h` и настройте обработку в `MQTTManager`.
- Для поддержки нескольких ферм используйте уникальный `deviceId`, изменив его в `constants.h`.

---

## Безопасность

- Пароль и логин от web-интерфейса для обновления прошивки хранятся в `passwords.json` (и `default_passwords.json`). Они не отправляются на GitHub и храняться только на вашем компьютере.
- Для web-интерфейса и OTA требуется аутентификация.
- Не публикуйте свои пароли в открытых репозиториях!

---

## Минимальные примеры кода

### Логирование

```cpp
// Создание логгера
auto logger = farm::log::LoggerFactory::createSerialMQTTLogger(farm::log::Level::Info);

// Использование
logger->log(farm::log::Level::Info, "Температура: %.1f°C", temperature);
```

### Датчики

```cpp
// Создание и инициализация датчика
auto dht22 = std::make_shared<farm::sensors::DHT22_Temperature>(logger,             farm::config::sensors::pins::DHT22_PIN);
dht22->initialize();

// Чтение данных
float temp = dht22->read();
dht22->saveMeasurement();
```

### Планировщик

```cpp
// Создание планировщика
auto scheduler = farm::utils::Scheduler::getInstance(logger);
scheduler->initialize(farm::config::time::DEFAULT_GMT_OFFSET);

// Планирование событий
scheduler->scheduleOnceAt("12:00", []() {
    // Действие в полдень
});

scheduler->schedulePeriodicAt("08:00", 3600, []() {
    // Действие каждый час с 8:00
});
```

### MQTT

```cpp
// Инициализация MQTT
auto mqtt = farm::net::MQTTManager::getInstance(logger);
mqtt->initialize();

// Публикация данных с датчиков
mqtt->publishData();
```

### OTA Обновления

```cpp
// Инициализация OTA
auto ota = farm::net::OTAManager::getInstance(logger);
ota->initialize();

// В loop()
ota->handle();
```

### Веб-сервер

```cpp
// Инициализация веб-сервера
auto webServer = farm::net::WebServerManager::getInstance(logger);
webServer->initialize();

// В loop()
webServer->handleClient();
```

## Пример полной инициализации

```cpp
void setup() {
    // Логгер
    auto logger = farm::log::LoggerFactory::createSerialMQTTLogger(farm::log::Level::Info);
    
    // Менеджеры
    auto configManager = farm::config::ConfigManager::getInstance(logger);
    auto wifiManager = farm::net::MyWiFiManager::getInstance(logger);
    auto mqttManager = farm::net::MQTTManager::getInstance(logger);
    auto sensorsManager = farm::sensors::SensorsManager::getInstance(logger);
    auto otaManager = farm::net::OTAManager::getInstance(logger);
    auto webServerManager = farm::net::WebServerManager::getInstance(logger);
    auto schedulerManager = farm::utils::Scheduler::getInstance(logger);
    
    // Инициализация
    configManager->initialize();
    wifiManager->initialize();
    mqttManager->initialize();
    sensorsManager->initialize();
    otaManager->initialize();
    webServerManager->initialize();
    schedulerManager->initialize(farm::config::time::DEFAULT_GMT_OFFSET);
}
```

## Основной цикл

```cpp
void loop() {
    // Поддержка соединений
    wifiManager->maintainConnection();
    mqttManager->maintainConnection();
    
    // Обработка датчиков
    sensorsManager->loop();
    
    // Проверка расписания
    schedulerManager->checkSchedule();
    
    // OTA и веб-сервер
    otaManager->handle();
    webServerManager->handleClient();
    
    delay(farm::config::loop::DEFAULT_DELAY_MS);
}
```

## FAQ и советы

- **Нужно ли каждый раз подключаться к WiFi?** Нет, только при первом запуске или сбросе настроек. Для работы актуаторов требуется хотя бы однократная синхронизация времени через интернет.
- **Что делать, если настройки сбились?** Загрузите дефолтные файлы через `pio run --target uploadfs` и повторите настройку.
- **Как удалить настройки?** Используйте функцию сброса в WiFiManager или удалите файлы конфигурации из SPIFFS.

---

## Важные замечания

- Поддерживается только один расходомер YFS401 на систему!
- Для корректной работы актуаторов требуется хотя бы однократная синхронизация времени через интернет.
- Все схемы подключения и калибровки описаны в заголовочных файлах датчиков и нарисованы в scheme.pdf.
- Дефолтные файлы конфигурации обязательны для первого запуска!

---

## Контакты и поддержка

Если у вас возникли вопросы или предложения по развитию проекта — создайте issue или pull request в репозитории.
Либо можете написать мне лично: t.me/@medveduuk

---



